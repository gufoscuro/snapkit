#!/usr/bin/env node

import { mkdir, readdir, readFile, writeFile } from 'fs/promises';
import { dirname, join, relative } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');
const COMPONENTS_DIR = join(PROJECT_ROOT, 'src/lib/components/features');
const OUTPUT_FILE = join(PROJECT_ROOT, 'src/generated/components-registry.ts');

// File patterns to exclude
const EXCLUDE_PATTERNS = [
  /\.test\.(ts|js|svelte)$/,
  /\.spec\.(ts|js|svelte)$/,
];

/**
 * Recursively find all .svelte files in a directory
 */
async function findSvelteFiles(dir, fileList = []) {
  const files = await readdir(dir, { withFileTypes: true });

  for (const file of files) {
    const filePath = join(dir, file.name);

    if (file.isDirectory()) {
      await findSvelteFiles(filePath, fileList);
    } else if (file.name.endsWith('.svelte')) {
      // Check if file should be excluded
      const shouldExclude = EXCLUDE_PATTERNS.some(pattern => pattern.test(file.name));
      if (!shouldExclude) {
        fileList.push(filePath);
      }
    }
  }

  return fileList;
}

/**
 * Extract JSDoc description from a Svelte component
 * Supports both HTML comments and JSDoc comments
 */
function extractDescription(content) {
  // First, try to find HTML comment at the start of the file (Svelte style)
  const htmlCommentPattern = /<!--\s*([\s\S]*?)\s*-->/;
  const htmlMatch = content.match(htmlCommentPattern);

  if (htmlMatch) {
    const commentContent = htmlMatch[1];
    // Look for @description tag
    const descriptionMatch = commentContent.match(/@description\s+(.+?)(?=\n\s*@|\n\s*$)/s);

    if (descriptionMatch) {
      return descriptionMatch[1].trim().replace(/\s+/g, ' ');
    }
  }

  // Fallback: Look for JSDoc comment (/**...*/)
  const jsdocPattern = /\/\*\*\s*\n([^*]|\*(?!\/))*\*\//;
  const jsdocMatch = content.match(jsdocPattern);

  if (jsdocMatch) {
    const jsdocContent = jsdocMatch[0];
    const descriptionMatch = jsdocContent.match(/@description\s+(.+?)(?=\n\s*\*\s*@|\n\s*\*\/)/s);

    if (descriptionMatch) {
      return descriptionMatch[1].trim().replace(/\s+/g, ' ');
    }

    // If no @description tag, try to get the first line of the comment
    const firstLineMatch = jsdocContent.match(/\/\*\*\s*\n\s*\*\s*(.+?)(?=\n|$)/);
    if (firstLineMatch) {
      return firstLineMatch[1].trim();
    }
  }

  return null;
}

/**
 * Generate registry key from file path
 * Example: src/lib/components/features/orders/PageFilters/default/PageFilters.svelte
 * -> orders.pagefilters.default.PageFilters
 *
 * Folders are lowercased, but filename (last part) preserves its original casing
 */
function generateKey(filePath) {
  const relativePath = relative(COMPONENTS_DIR, filePath);
  const parts = relativePath.split('/');

  // Remove .svelte extension from last part (filename)
  const filename = parts[parts.length - 1].replace('.svelte', '');

  // Lowercase all folder parts, preserve filename casing
  const folders = parts.slice(0, -1).map(part => part.toLowerCase());

  // Join folders with filename
  return [...folders, filename].join('.');
}

/**
 * Generate import path for Vite alias
 */
function generateImportPath(filePath) {
  const relativePath = relative(join(PROJECT_ROOT, 'src/lib'), filePath);
  return `$lib/${relativePath}`;
}

/**
 * Generate the registry file content
 */
async function generateRegistry() {
  console.log('üîç Scanning for Svelte components in:', COMPONENTS_DIR);

  const files = await findSvelteFiles(COMPONENTS_DIR);
  console.log(`‚úì Found ${files.length} components`);

  const registryEntries = [];

  for (const filePath of files) {
    const content = await readFile(filePath, 'utf-8');
    const key = generateKey(filePath);
    const importPath = generateImportPath(filePath);
    const description = extractDescription(content) || `${key.split('.').pop()} component`;
    console.log('description', description);

    registryEntries.push({
      key,
      importPath,
      description,
    });
  }

  // Sort by key for consistent output
  registryEntries.sort((a, b) => a.key.localeCompare(b.key));

  // Generate TypeScript content
  const registryContent = registryEntries
    .map(({ key, importPath, description }) => {
      return `  '${key}': {
    component: () => import('${importPath}'),
    description: '${description.replace(/'/g, "\\'")}',
  }`;
    })
    .join(',\n');

  const fileContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: npm run generate:components-registry
 * Last updated: ${new Date().toISOString()}
 */

export const COMPONENT_REGISTRY = {
${registryContent}
} as const;

export type ComponentKey = keyof typeof COMPONENT_REGISTRY;

export type ComponentDefinition = {
  component: () => Promise<any>;
  description: string;
};

export function getComponent(key: ComponentKey): ComponentDefinition {
  return COMPONENT_REGISTRY[key];
}

export function getAllComponentKeys(): ComponentKey[] {
  return Object.keys(COMPONENT_REGISTRY) as ComponentKey[];
}
`;

  // Ensure output directory exists
  await mkdir(dirname(OUTPUT_FILE), { recursive: true });

  // Write the file
  await writeFile(OUTPUT_FILE, fileContent, 'utf-8');

  console.log(`‚ú® Registry generated successfully!`);
  console.log(`üìÅ Output: ${relative(PROJECT_ROOT, OUTPUT_FILE)}`);
  console.log(`üì¶ Components registered: ${registryEntries.length}`);
  console.log('\nRegistry keys:');
  registryEntries.forEach(({ key }) => console.log(`  - ${key}`));
}

// Run the script
generateRegistry().catch((error) => {
  console.error('‚ùå Error generating registry:', error);
  process.exit(1);
});
