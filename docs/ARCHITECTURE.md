# Snapkit Architecture

Snapkit is an AI-assisted customization framework for ERP systems built on SvelteKit, TypeScript, and shadcn-svelte. It implements a **declarative page architecture** with **dynamic component resolution** and **typed state sharing** between components.

## Design Goals

1. **Declarative Page Configuration** - Define pages via metadata, not scattered route files
2. **Composable Layouts** - Plug any component into any layout slot
3. **Decoupled Component Communication** - Components share state without importing each other
4. **Abstract Page References** - Reference pages by `$id`, not hardcoded URLs
5. **AI-Friendly Development** - MCP servers provide context for AI-assisted building

---

## Core Systems

### 1. Page Registry

The page registry (`src/lib/utils/page-registry.ts`) is the declarative layer defining all pages in the system.

```typescript
interface PageConfig {
  $id: string                              // Unique identifier for route generation
  $params?: TObject                        // TypeBox schema for route parameters
  title: string                            // Display title
  route: string                            // Route pattern (e.g., '/orders/:uuid')
  layout: SnippetDefinition               // Layout component to render
  snippets: Record<string, SnippetDefinition>  // Named content slots
}

interface SnippetDefinition {
  componentKey: ComponentKey              // Reference to component registry
  enabled: boolean                        // Feature flag
  bindings?: BindingConfig               // Namespace mapping for state
}
```

**Example:**
```typescript
{
  $id: 'order-detail',
  $params: Type.Object({ uuid: Type.String() }),
  title: 'Order Detail',
  route: '/orders/:uuid',
  layout: { componentKey: 'layouts.Detail', enabled: true },
  snippets: {
    header: { componentKey: 'orders.DetailHeader', enabled: true },
    items: { componentKey: 'orders.ItemsTable', enabled: true }
  }
}
```

**Route Matching:**
Uses `path-to-regexp` for pattern matching. The `getPageByRoute()` function matches incoming URLs against registered patterns and extracts parameters.

---

### 2. Route Builder

The route builder (`src/lib/utils/route-builder.ts`) generates URLs from page `$id`s, eliminating hardcoded URLs.

```typescript
import { createRoute } from '$lib/utils/route-builder'

// Without parameters
createRoute({ $id: 'order-list' })
// → '/orders'

// With path parameters
createRoute({ $id: 'order-detail', params: { uuid: '123' } })
// → '/orders/123'

// With query parameters
createRoute({ $id: 'order-list', query: { status: 'pending', page: 1 } })
// → '/orders?status=pending&page=1'
```

**Performance:**
Compiled route functions are cached in a `Map` to avoid recompilation on each call.

**Validation:**
In development mode, parameters are validated against the TypeBox `$params` schema.

---

### 3. Component Registry

The component registry (`src/generated/components-registry.ts`) is auto-generated by scanning `src/lib/components/features/`.

```typescript
export const COMPONENT_REGISTRY = {
  'orders.pagetable.default.PageTable': {
    component: () => import('$lib/components/features/orders/PageTable/default/PageTable.svelte'),
    description: 'PageTable component'
  },
  'layouts.List': {
    component: () => import('$lib/components/features/layouts/List.svelte'),
    description: 'List layout'
  },
  // ...
} as const

export type ComponentKey = keyof typeof COMPONENT_REGISTRY
```

**Key Naming Convention:**
- Path: `src/lib/components/features/orders/PageFilters/default/PageFilters.svelte`
- Key: `orders.pagefilters.default.PageFilters`

**Regeneration:**
```bash
npm run generate:components-registry
```

---

### 4. State Sharing System

Located in `src/lib/contexts/page-state/`, this system enables typed communication between components without direct imports.

#### Core Concepts

| Concept | Description |
|---------|-------------|
| **PageState** | Central reactive store for all component state within a page |
| **ComponentContract** | Describes what a component provides and consumes |
| **Bindings** | Maps logical names to actual namespaces |
| **StateHandle** | Typed interface for reading/writing state |

#### Component Contract

```typescript
import { Type } from '@sinclair/typebox'
import type { ComponentContract } from '$lib/contexts/page-state'

export const FilterContract = {
  $id: 'FilterComponent',
  provides: {
    filters: Type.Object({
      search: Type.String(),
      status: Type.Array(Type.String())
    })
  },
  consumes: {}
} as const satisfies ComponentContract
```

#### Using State Handles

**Provider (writes state):**
```typescript
import { useProvides } from '$lib/contexts/page-state'

const filtersHandle = useProvides(FilterContract, 'filters')

// Set state
filtersHandle.set({ search: 'query', status: ['pending'] })

// Update state
filtersHandle.update(current => ({ ...current, status: ['shipped'] }))
```

**Consumer (reads state):**
```typescript
import { useConsumes } from '$lib/contexts/page-state'

const filtersHandle = useConsumes(TableContract, 'filters')

// Read state (may be undefined)
const filters = filtersHandle.get()

// Use in derived
const filteredItems = $derived.by(() => {
  const f = filtersHandle.get()
  return f ? items.filter(matchesFilter(f)) : items
})
```

#### Bindings Configuration

Bindings map logical names to actual PageState namespaces:

```typescript
// In page registry
{
  componentKey: 'orders.Table',
  bindings: {
    consumes: { filters: 'search.filters' }  // Remap 'filters' to 'search.filters'
  }
}
```

Default behavior: logical name equals namespace (e.g., `filters` → `filters`).

---

### 5. Runtime Resolution

#### SnippetResolver

`src/lib/components/runtime/SnippetResolver.svelte` dynamically loads and renders components:

1. Lazy loads component from registry
2. Checks for exported `contract`
3. If contract exists, wraps in `SnippetBindingsProvider`
4. Renders component with snippet props context

```svelte
<SnippetResolver snippet={config.snippets.filters} />
```

#### SnippetBindingsProvider

Sets up bindings context for components with contracts, resolving logical names to namespaces.

---

### 6. Layout System

Layouts are components that define page structure and render snippets into slots.

**List Layout** (`layouts.List`):
```svelte
<AppHeader />
<main>
  <SnippetResolver snippet={config.snippets.title} />
  <SnippetResolver snippet={config.snippets.filters} />
  <SnippetResolver snippet={config.snippets.table} />
</main>
```

**Detail Layout** (`layouts.Detail`):
```svelte
<main>
  <SnippetResolver snippet={config.snippets.header} />
  <SnippetResolver snippet={config.snippets.content} />
</main>
```

---

## Data Flow

### Page Load

```
User navigates to /orders/123
         ↓
SvelteKit matches [...path] route
         ↓
+page.ts calls getPageByRoute('/orders/123')
         ↓
Route pattern /orders/:uuid matches → params: { uuid: '123' }
         ↓
+page.svelte initializes PageState context
         ↓
SnippetResolver loads layout component
         ↓
Layout renders snippets via SnippetResolver
         ↓
Components mount with state handles available
```

### State Sharing

```
FilterComponent mounts
         ↓
useProvides(FilterContract, 'filters') creates handle
         ↓
User types in search input
         ↓
filtersHandle.set({ search: 'text', status: [] })
         ↓
PageState updates internal $state
         ↓
Svelte reactivity triggers
         ↓
TableComponent's $derived re-evaluates
         ↓
filtersHandle.get() returns new filter state
         ↓
Table re-renders with filtered items
```

---

## File Structure

```
src/
├── lib/
│   ├── components/
│   │   ├── ui/                    # Base UI (shadcn-svelte, do not modify)
│   │   ├── features/              # Domain components (auto-discovered)
│   │   │   ├── layouts/           # Page layouts
│   │   │   ├── globals/           # Shared components (AppHeader, PageTitle)
│   │   │   ├── orders/            # Order domain
│   │   │   ├── materials/         # Materials domain
│   │   │   ├── form/              # Form utilities
│   │   │   └── _poc/              # Proof-of-concept demos
│   │   └── runtime/               # SnippetResolver, SnippetBindingsProvider
│   ├── contexts/
│   │   └── page-state/            # State sharing system
│   └── utils/
│       ├── page-registry.ts       # Page definitions
│       ├── route-builder.ts       # URL generation
│       └── request.ts             # API utilities
├── generated/
│   └── components-registry.ts     # Auto-generated component map
└── routes/
    └── [...path]/                 # Catch-all route handler
        ├── +page.ts               # Route matching
        └── +page.svelte           # Page rendering
```

---

## Creating New Components

### Simple Component

```svelte
<!-- src/lib/components/features/orders/OrderBadge.svelte -->
<script lang="ts">
  import { Badge } from '$lib/components/ui/badge'

  const { status }: { status: string } = $props()
</script>

<Badge variant={status === 'shipped' ? 'default' : 'secondary'}>
  {status}
</Badge>
```

### Component with Contract

**1. Define contract:**
```typescript
// src/lib/components/features/orders/OrderFilters/OrderFilters.contract.ts
import { Type } from '@sinclair/typebox'
import type { ComponentContract } from '$lib/contexts/page-state'

export const OrderFiltersContract = {
  $id: 'OrderFilters',
  provides: {
    filters: Type.Object({
      search: Type.String(),
      status: Type.Array(Type.String())
    })
  },
  consumes: {}
} as const satisfies ComponentContract
```

**2. Create component:**
```svelte
<!-- src/lib/components/features/orders/OrderFilters/OrderFilters.svelte -->
<script lang="ts" module>
  export { OrderFiltersContract as contract } from './OrderFilters.contract'
</script>

<script lang="ts">
  import { useProvides } from '$lib/contexts/page-state'
  import { OrderFiltersContract } from './OrderFilters.contract'

  const filtersHandle = useProvides(OrderFiltersContract, 'filters')

  let search = $state('')
  let status = $state<string[]>([])

  $effect(() => {
    filtersHandle.set({ search, status })
  })
</script>

<input bind:value={search} placeholder="Search..." />
<!-- status toggles -->
```

**3. Regenerate registry:**
```bash
npm run generate:components-registry
```

**4. Use in page config:**
```typescript
{
  $id: 'order-list',
  snippets: {
    filters: {
      componentKey: 'orders.orderfilters.OrderFilters',
      enabled: true
    }
  }
}
```

---

## MCP Server Integration

The project uses multiple MCP servers configured in `CLAUDE.md`:

| Server | Purpose |
|--------|---------|
| **svelte** | Svelte 5 & SvelteKit documentation |
| **shadcn-svelte** | Base UI component docs |
| **shadcn-svelte-extras** | Extra components via jsrepo |
| **svelte-components** | Feature component discovery |
| **arke** | Backend API exploration |

These servers provide context for AI-assisted development, enabling:
- Automatic code fixes via `svelte-autofixer`
- Component discovery without manual searching
- API endpoint discovery for data fetching

---

## Key Dependencies

| Package | Purpose |
|---------|---------|
| `@sveltejs/kit` | Framework |
| `svelte` | Language (v5 with runes) |
| `@sinclair/typebox` | Schema validation & type inference |
| `path-to-regexp` | Route pattern matching |
| `bits-ui` | Headless component primitives |
| `shadcn-svelte` | UI component library |

---

## Design Principles

1. **Configuration Over Code** - Pages defined declaratively, enabling runtime customization
2. **Type-Safe Contracts** - TypeBox provides both runtime validation and TypeScript types
3. **Lazy Loading** - Components loaded on demand via dynamic imports
4. **Reactive Derived State** - Svelte 5 `$derived` keeps computed values in sync
5. **Context-Based DI** - Components receive dependencies via context, not props drilling
6. **Decoupled Communication** - Components share state without knowing each other

This architecture transforms Snapkit from a typical web app into a **metadata-driven platform** where business logic is expressed as configuration.
